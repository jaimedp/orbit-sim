(function () {
'use strict';

var AU = 149.6e6 * 1000;
var G = 6.67428e-11;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var Universe = function () {
  function Universe(bodies) {
    classCallCheck(this, Universe);

    this.bodies = bodies;

    // default to 1 day timestep
    this.dt = 24 * 3600;
  }

  createClass(Universe, [{
    key: 'step',
    value: function step() {
      var _this = this;

      // calculate all the forces for all bodies... this is O(n^2)... watch out
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.bodies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var body = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this.bodies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var other = _step2.value;

              if (body === other) {
                continue;
              }

              var F = body.computeAttraction(other);
              body.addForce(F.fx, F.fy);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        // integrate new position for all bodies
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.bodies.forEach(function (b) {
        b.integrate(_this.dt);
      });
    }
  }, {
    key: 'render',
    value: function render(ctx, toScreen) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // render new pos
      this.bodies.forEach(function (b) {
        return b.render(ctx, toScreen);
      });

      if (options.info) {
        var text = this.bodies.map(function (b) {
          return b.name + ': Pos: ' + (b.x / AU).toFixed(4) + ', ' + (b.y / AU).toFixed(4) + ', Vel: ' + b.vx.toFixed(4) + ', ' + b.vy.toFixed(4);
        }).join('<br>');
        options.info.innerHTML = text;
      }
    }
  }]);
  return Universe;
}();

var defaultOptions = Object.freeze({
  color: '#f00'
});

var Body = function () {
  function Body() {
    var mass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Body';
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Body);

    this.name = name;
    this.mass = mass;
    this.options = Object.assign({}, defaultOptions, options);

    this.rad = 5;

    this.x = this.options.x || 0;
    this.y = this.options.y || 0;
    this.vx = this.options.vx || 0;
    this.vy = this.options.vy || 0;

    this.forces = { x: 0, y: 0 };
    this.prevForces = { x: 0, y: 0 };
  }

  createClass(Body, [{
    key: 'computeAttraction',
    value: function computeAttraction(other) {

      var dx = other.x - this.x;
      var dy = other.y - this.y;

      var d2 = dx * dx + dy * dy;

      if (d2 === 0) {
        throw new Error('collision!');
      }

      // gravitational force between two bodies is:
      // G * M1 * m2 / dist^2
      var f = G * this.mass * other.mass / d2;

      // now compute the components of the force
      var t = Math.atan2(dy, dx);

      return {
        fx: Math.cos(t) * f,
        fy: Math.sin(t) * f
      };
    }
  }, {
    key: 'addForce',
    value: function addForce(fx, fy) {
      this.forces.x += fx;
      this.forces.y += fy;
    }

    // simple euler integration

  }, {
    key: 'integrate',
    value: function integrate(dt) {
      var fx = this.forces.x;
      var fy = this.forces.y;

      // v = v0 + F / M * dt
      this.vx += fx / this.mass * dt;
      this.vy += fy / this.mass * dt;

      // p = p0 + v * dt
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // keep track of the force for debugging
      this.prevForces.x = this.forces.x;
      this.prevForces.y = this.forces.y;

      this.forces.x = 0;
      this.forces.y = 0;
    }
  }, {
    key: 'render',
    value: function render(ctx, toScreen) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var pos = toScreen(this.x, this.y);

      ctx.beginPath();
      ctx.arc(pos.x, pos.y, this.rad, 0, 2 * Math.PI, false);
      ctx.fillStyle = this.options.color;
      ctx.fill();

      if (options.debugForce) {
        ctx.beginPath();
        var scale = 1 / 1.0e19;
        var _x = pos.x + this.prevForces.x * scale;
        var _y = pos.y + this.prevForces.y * scale;
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(_x, _y);
        ctx.strokeStyle = 'red';
        ctx.stroke();
      }
    }
  }]);
  return Body;
}();

var SCALE = 50 / AU;

var b1 = new Body(1.98892 * Math.pow(10, 30), 'sun', { color: 'yellow' });
var b2 = new Body(5.9742 * Math.pow(10, 24), 'earth', { color: 'blue', x: -1 * AU, vy: 29.783 * 1000 });
var b3 = new Body(4.8685 * Math.pow(10, 24), 'venus', { color: 'red', x: 0.723 * AU, vy: -35.02 * 1000 });

var universe = new Universe([b1, b2, b3]);

var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');
var centerX = canvas.width / 2;
var centerY = canvas.height / 2;

var toScreen = function toScreen(x, y) {
  return { x: x * SCALE + centerX, y: centerY + y * SCALE };
};
var btn = document.getElementById('step');

var step$1 = function step$1() {
  universe.step();
  context.clearRect(0, 0, canvas.width, canvas.height);
  universe.render(context, toScreen, { info: document.getElementById('info') });
};

setInterval(function () {
  return step$1();
}, 16);

btn.addEventListener('click', function () {
  step$1();
});

}());
//# sourceMappingURL=main.min.js.map
